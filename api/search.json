[{"id":"17e78b64810282ffd93c25608f3b11d9","title":"Golang-RCP協議","content":"RPC: 遠程行程(進程，單一程式)調用協議，使用TCP，屬於應用層協議，與http協議同層==可理解為調用內部函數一樣，調用網路中其他程式的函數==通過RPC協議，傳遞：函數名、參數，從原處調用另一處函數，返回結果到原處\n\n每個微服務彼此獨立\n程式與程式之間可使用不同程式語言\n\n前導知識 Go socketservernet.Listen() -- listener\nlistener.Accept() -- conn\nconn.read()\nconn.write()\ndefer conn.close()&#x2F;listener.Close()\n\nclientnet.Dial() -- conn\nconn.Write()\nconn.Read()\ndefer conn.Close()\n\nRPC使用步驟server\n註冊RPC服務對象，給對象綁定方法(1.定義類 2.綁定類方法)rpc.RegisterName(&lt;服務名&gt;, &lt;回調對象&gt;)\n創建監聽器listener, err :&#x3D; net.Listen()\n建立連結conn, err :&#x3D; listener.Accept()\n將連結綁定RPC服務rpc.ServeConn(conn)\n\nclient\n用RPC連結serverconn, err :&#x3D; rpc.Dial()\n調用遠程函數conn.Call(&lt;服務名.方法名&gt;, &lt;傳入參數&gt;, &lt;傳出參數&gt;)\n\nRPC相關函數\n==RegisterName()== 註冊服務\nfunc (server *Server) RegisterName(name&lt;服務名&gt; string, rcvr&lt;對應rpc對象&gt; interface&#123;&#125;) error\nrcvr必須滿足條件：(1) 必須導出：public, 首字母大寫(2) 方法必須有2個參數：public、內建類型(3) 第2個參數為指針(4) 方法只有一個error接口返回值\ntype Sample struct&#123;\n&#125;\n\nfunc (this *Sample) Test(name string, resp *string) error &#123;\n&#125;\n\nrpc.RegisterName(&quot;服務名&quot;, new(Test))\n==ServeConn()== 綁定rpc服務\nfunc (server *Server) ServeConn(conn io.ReadWriteCloser)\nconn: 建立連線的socket\n\n==Call()== 調用遠程函數\nfunc (client *Client) Go(serviceMethod string, args interface&#123;&#125;, reply interface&#123;&#125;, done chan *Call) *Call\nserviceMethod: 服務名.方法名args: 傳入參數(方法需要的參數)reply: 傳出參數(方法返回的結果)(建立變量，&amp;變量)\n\n\nDEMOserver端package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&quot;\n\t&quot;net&#x2F;rpc&quot;\n)\n\n&#x2F;&#x2F; 定義對象\ntype Sample struct &#123;\n&#125;\n\n&#x2F;&#x2F; 建立方法\nfunc (this *Sample) TestSample(name string, resp *string) error &#123;\n\t*resp &#x3D; name + &quot;返回&quot;\n\treturn nil\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 1. 註冊rpc，綁定對象方法\n\terr :&#x3D; rpc.RegisterName(&quot;service&quot;, new(Sample))\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;註冊rpc失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\n\t&#x2F;&#x2F; 2. 設置監聽\n\tlistener, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;設置監聽失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer listener.Close()\n\tfmt.Println(&quot;Start Listen...&quot;)\n\n\t&#x2F;&#x2F; 3. 建立連結\n\tconn, err :&#x3D; listener.Accept()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;建立連結失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer conn.Close()\n\tfmt.Println(&quot;Start Connect...&quot;)\n\n\t&#x2F;&#x2F; 4. 綁定服務\n\trpc.ServeConn(conn)\n&#125;\n\nclient端package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&#x2F;rpc&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 1. 用rpc連接server\n\tconn, err :&#x3D; rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;rpc連接失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer conn.Close()\n\t&#x2F;&#x2F; 2. 調用遠程函數\n\tvar req string\n\terr &#x3D; conn.Call(&quot;service.TestSample&quot;, &quot;something&quot;, &amp;req)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;調用遠程函數失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\n\tfmt.Println(req)\n&#125;\n\n\n序列化因為rpc使用go特有序列化gob，網路通訊中其他語言將會產生亂碼因此需使用通用序列化、反序列化方案：JSON、protobuf\n有內建package ==”net/rpc/jsonrpc”==\nserverjsonrpc.ServeConn(conn)\n\nclient端```conn, err := jsonrpc.Dial(“tcp”, “127.0.0.1:8800”)\n","slug":"Golang-RCP協議","date":"2021-09-09T13:26:59.000Z","categories_index":"Golang","tags_index":"RPC,網路架構","author_index":"猴子工程師"},{"id":"a47de5cab978593bde43925482e0346b","title":"Angular-色彩主題切換","content":"簡單介紹一下色彩切換功能\n建立2個獨立的主題$dark-primary: mat-palette($dark-primary, 900);\n$dark-accent:  mat-palette($mat-cyan);\n$dark-warn:    mat-palette($mat-red);\n\n$dark-theme: mat-dark-theme($dark-primary, $dark-accent, $dark-warn);\n&#x2F;&#x2F; class包裹其他樣式\n.dark-theme &#123;\n  @include angular-material-theme($dark-theme);\n&#125;\n\n$light-primary: mat-palette($mat-indigo);\n$light-accent:  mat-palette($mat-lime);\n$light-warn:    mat-palette($mat-pink);\n\n$light-theme: mat-light-theme($light-primary, $light-accent, $light-warn);\n&#x2F;&#x2F; class包裹其他樣式\n.light-theme &#123;\n  @include angular-material-theme($light-theme);\n&#125;\n\n在app.component建立切換功能material-UI中，menu、dialog等元件在OverlayContainer，與app.component平級，所以額外改變其樣式\nhtml&lt;div [class]&#x3D;&quot;theme&quot;&gt;\n  &lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;\n&lt;&#x2F;div&gt;\n\ntsimport &#123; Component, OnInit &#125; from &#39;@angular&#x2F;core&#39;;\n\nimport &#123; OverlayContainer &#125; from &#39;@angular&#x2F;cdk&#x2F;overlay&#39;;\n\n@Component(&#123;\n  selector: &#39;app-root&#39;,\n  templateUrl: &#39;.&#x2F;app.component.html&#39;,\n  styleUrls: [&#39;.&#x2F;app.component.scss&#39;]\n&#125;)\nexport class AppComponent implements OnInit &#123;\n\n  constructor(private overlayContainer: OverlayContainer) &#123;&#125;\n\n  ngOnInit() &#123;\n    this.overlayContainer.getContainerElement().classList.add(this.theme);\n    toggleTheme(&#39;light-theme&#39;) &#x2F;&#x2F; 看想要怎麼觸發\n  &#125;\n\n  theme &#x3D; &#39;dark-theme&#39;;\n\n  toggleTheme(newTheme) &#123;\n    this.overlayContainer.getContainerElement().classList.remove(this.theme);\n    this.overlayContainer.getContainerElement().classList.add(newTheme);\n    this.theme &#x3D; newTheme;\n  &#125;\n&#125;\n","slug":"Angular-色彩主題切換","date":"2021-08-30T12:40:22.000Z","categories_index":"Angular","tags_index":"Material-UI","author_index":"猴子工程師"},{"id":"957e53f31bd0fb9b5252ab0e19bc3aaa","title":"Docker-常用命令","content":"https://docs.docker.com/reference/\n幫助命令版本訊息\ndocker version\n系統訊息，包含鏡像與容器數量\ndocker info\n幫助命令\ndocker &lt;&gt; --help\n\n鏡像命令docker imagesdocker images\n\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\n鏡像倉庫源      標籤         id           創建時間        大小\n\n可選項\n\n-a, -all 所有鏡像\n-q, --quiet  只顯示id\n\ndocker searchdocker search &lt;名稱&gt;\n\n--filter&#x3D;STARS&#x3D;3000 搜索不小於3000\n\ndocker pulldocker pull &lt;名稱&gt;:&lt;版本 &gt;\n\ndocker rmidocker rmi -f &lt;名稱或id&gt;\n\n全刪\ndocker rmi -f $(docker images -aq)\n\n\n\n容器命令先有鏡像，才能創造容器\ndocker rundocker run &lt;參數&gt; &lt;image&gt;\n\n--name&#x3D;&quot;名字&quot; 容器名字\n-d 後臺運行\n-it 交互運行，可進入容器查看\n-p 指定port 主機:容器\n\ndocker run -it centos &#x2F;bin&#x2F;bash 啟動centos並進入\nexit 停止退出\nCtrl + p + q 不停止退出\n\ndocker psdocker ps 正在執行的\n-a  全部運行的\n-n&#x3D;1 最近1個\n-q 只顯示編號\n\ndocker rmdocker rm &lt;id&gt;\n\n全刪\ndocker rm -f $(docker ps -aq)\ndocker ps -a -q | xargs docker rm\n\ndocker start restart stop killdocker start &lt;id&gt;\ndocker restart &lt;id&gt;\ndocker stop &lt;id&gt;\ndocker kill &lt;id&gt;  強制停止\n\n後臺啟動docker run -d &lt;名字&gt; \ndocker ps  容器停止了\n常見錯誤： docker容器後台運行，需要前台進程，如果沒有就會自動停止\n\ndocker logsdocker logs -tf  &lt;id&gt;  全部\ndocker logs -tf --tail &lt;數量&gt; &lt;id&gt;  最近\n插播：如何在docker centos寫腳本\ndocker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo SoGod; sleep 1;done&quot;\n\ndocker topdocker top &lt;id&gt;  查看進程訊息\n\ndocker inspectdocker inspect &lt;id&gt;  查看容器詳細訊息\n\ndocker execdocker exec -it &lt;id&gt; &#x2F;bin&#x2F;bash  進入正在運行的容器並開始新的終端\ndocker attach &lt;id&gt; 進入正在運行的容器，使用正在執行的終端\n\ndocker cpdocker cp &lt;id&gt;:&lt;容器路徑&gt; &lt;主機路徑&gt;  查看容器詳細訊息\n\n此處為手動。一般使用自動同步\n\ndocker commitdocker commit &lt;id&gt; &lt;目標鏡像名&gt;:&lt;tag&gt; 將容器提交為新的鏡像\n-m&#x3D;&quot;訊息&quot;\n-a&#x3D;&quot;作者&quot;\n","slug":"Docker-常用命令","date":"2021-08-22T07:33:44.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"猴子工程師"}]