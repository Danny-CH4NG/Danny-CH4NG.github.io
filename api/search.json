[{"id":"8b84f4b495ddc0e37d7c4996da47c833","title":"Golang-Gin框架-GORM搭建APIServer-3","content":"[Golang] Gin框架+GORM 搭建API Server(3)前言上一節完成了基本的路由註冊功能，本節將完成對資料庫的連線部分。根據第一節，建立了\n\ndevice_infos\ndevice_states\ndevice_actives\n\n而三支API分別為\n\n/api/v1/actives/:active：\nSELECT device_actives WHERE active=? JOIN device_infos \nSELECT actives WHERE active=?\n\n\n/api/v1/actives/:device_id：\nUPDATE device_actives SET active=1 WHERE device_id=?\n\n\n/api/v1/states/:state：\nSELECT device_states WHERE state=? JOIN device_infos\n\n\n\n將完成資料庫select、update、join等操作\n本節目標\n建立actives的view結合device_infos與device_actives，避免每次查詢重覆join\n建立GORM Model架構\n完成API與GORM對接\n\n基本目錄結構server&#x2F;\n├── config &#x2F;&#x2F; 配置讀取yaml設定\n│   └── config.go &#x2F;&#x2F; 讀取yml設定\n├── middleware &#x2F;&#x2F; 中間件\n├── models &#x2F;&#x2F; 放置gorm的數據庫模型\n│   ├── actives.go &#x2F;&#x2F; 對應actives檢視表\n│   ├── device_actives.go &#x2F;&#x2F; 對應device_actives資料表\n│   ├── device_infos.go &#x2F;&#x2F; 對應device_infos資料表\n│   ├── device_states.go &#x2F;&#x2F; 對應device_states資料表\n│   └── models.go &#x2F;&#x2F; model init\n├── routers &#x2F;&#x2F; 路由邏輯\n│   ├── api\n│   │   └── v1\n│   │       ├── actives.go &#x2F;&#x2F; actives相關api\n│   │       └── states.go &#x2F;&#x2F; states相關api\n│   └── router.go &#x2F;&#x2F; 路由邏輯\n├── config.yml &#x2F;&#x2F; 設定檔\n└── server.go &#x2F;&#x2F; 入口\n\nPostgreSQL建立檢視表避免查詢多次JOIN浪費效能，並可以讓整體架構更清晰\nactivesCREATE OR REPLACE VIEW public.actives\n AS\n SELECT device_actives.device_id,\n    device_infos.type,\n    device_infos.address,\n    device_actives.active\n   FROM device_infos,\n    device_actives\n  WHERE device_infos.device_id::text &#x3D; device_actives.device_id::text;\n\n建立資料在device_actives表與devices_infos表建立對應資料，查看actives表是否如預期顯示\ndevice_activesINSERT INTO public.device_actives(\n\tdevice_id, active)\n\tVALUES (&#39;test001&#39;, 0);\ndevices_infosINSERT INTO public.device_infos(\n\tdevice_id, type, address)\n\tVALUES (&#39;test001&#39;, &#39;test&#39;, &#39;測試地址&#39;);\ndevices_statesINSERT INTO public.device_states(\n\tdevice_id, state, update_time)\n\tVALUES (&#39;test001&#39;, 1, &#39;2021-10-19 05:49:25&#39;);\n建立GORM連線models.go建立db的連線，由config獲取連線資訊\npackage models\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;server&#x2F;config&quot;\n\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\n\t&quot;gorm.io&#x2F;driver&#x2F;postgres&quot;\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\n&#x2F;&#x2F; db實例\nvar db *gorm.DB\n\nfunc init() &#123;\n\tdsn :&#x3D; fmt.Sprintf(\n\t\t&quot;host&#x3D;%s port&#x3D;%s user&#x3D;%s password&#x3D;%s dbname&#x3D;%s sslmode&#x3D;disable&quot;,\n\t\tconfig.Config.Pgsql.IP,\n\t\tconfig.Config.Pgsql.Port,\n\t\tconfig.Config.Pgsql.User,\n\t\tconfig.Config.Pgsql.Password,\n\t\tconfig.Config.Pgsql.Database,\n\t)\n\n\tvar err error\n\n\t&#x2F;&#x2F; 嘗試連線PostgreSQL\n\t&#x2F;&#x2F; 注意：這裡不要用:&#x3D;，會改變db記憶體位置，db成為nil且不會報錯直到調用\n\tdb, err &#x3D; gorm.Open(postgres.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Error().Err(err).Msg(&quot;無法建立PostgreSQL連線&quot;)\n\t&#125; else &#123;\n\t\tlog.Info().Msg(&quot;成功建立PostgreSQL連線&quot;)\n\t&#125;\n\n\tsqlDB, err :&#x3D; db.DB()\n\tsqlDB.SetMaxIdleConns(10)  &#x2F;&#x2F; 設定最高空閒連接數\n\tsqlDB.SetMaxOpenConns(100) &#x2F;&#x2F; 設定最高併發數\n&#125;\n\n&#x2F;&#x2F; 關閉DB(不可寫在init，init階段結束會直接觸發)\nfunc CloseDB() &#123;\n\tsqlDB, _ :&#x3D; db.DB()\n\tdefer sqlDB.Close()\n&#125;\n\n設備狀態請求與獲取資料models/actives.go將表的欄位以struct進行對應，並填寫輸出成json的樣式\npackage models\n\n&#x2F;&#x2F; actives表的模型\ntype Actives struct &#123;\n\tDeviceId string &#96;json:&quot;deviceId&quot;&#96;\n\tType     string &#96;json:&quot;type&quot;&#96;\n\tAddress  string &#96;json:&quot;address&quot;&#96;\n\tActive   int    &#96;json:&quot;active&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 取得符合Actives條件的row\nfunc GetActives(maps interface&#123;&#125;) (res []Actives) &#123;\n\ta, ok :&#x3D; maps.(map[string]interface&#123;&#125;) &#x2F;&#x2F; 型別斷言為map\n\tif ok &amp;&amp; a[&quot;active&quot;] &#x3D;&#x3D; 99 &#123;           &#x2F;&#x2F; 如果請求值為99，則為全選\n\t\tdb.Find(&amp;res)\n\t&#125; else &#123;\n\t\tdb.Where(maps).Find(&amp;res)\n\t&#125;\n\treturn\n&#125;\nroutes/v1/actives.gopackage v1\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;strconv&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\n\t&quot;server&#x2F;models&quot;\n)\n\n&#x2F;&#x2F; 獲取已排除、未排除or全部的設備狀態\nfunc GetActives(c *gin.Context) &#123;\n\tactive :&#x3D; c.Param(&quot;active&quot;) &#x2F;&#x2F; 取得active值\n\n\treq :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 傳遞給GORM的參數\n\tres :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 準備回傳給前端的映射\n\n\tif active !&#x3D; &quot;&quot; &#123;\n\t\ti, err :&#x3D; strconv.Atoi(active) &#x2F;&#x2F; 字串轉數字\n\t\tif err !&#x3D; nil &#123;\n\t\t\tlog.Error().Err(err).Msg(&quot;字串轉數字錯誤&quot;)\n\t\t&#125;\n\t\treq[&quot;active&quot;] &#x3D; i\n\t&#125;\n\n\tres[&quot;data&quot;] &#x3D; models.GetActives(req)\n\tres[&quot;code&quot;] &#x3D; &quot;success&quot;\n\tc.JSON(http.StatusOK, res)\n&#125;\n\n&#x2F;&#x2F; 修改設備活躍狀態\nfunc EditActive(c *gin.Context) &#123;\n\tlog.Log().Msg(&quot;EditActive&quot;)\n&#125;\n\n測試Postman GEThttp://localhost:10080/api/v1/actives/0檢查是否回傳預想中的值，完成第一支API連線\n修改設備活躍狀態models/device_actives.gopackage models\n\ntype DeviceActives struct &#123;\n\tDeviceId string &#96;json:&quot;deviceId&quot; gorm:&quot;column:device_id&quot;&#96;\n\tActive   int    &#96;json:&quot;active&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 依據device_id toogle active欄位\nfunc UpdateDeviceActives(maps interface&#123;&#125;) (deviceActives DeviceActives) &#123;\n\tdb.Where(maps).First(&amp;deviceActives)\n\tif deviceActives.Active &#x3D;&#x3D; 0 &#123;\n\t\tdb.Model(&amp;DeviceActives&#123;&#125;).Where(maps).Update(&quot;active&quot;, 1)\n\t&#125; else if deviceActives.Active &#x3D;&#x3D; 1 &#123;\n\t\tdb.Model(&amp;DeviceActives&#123;&#125;).Where(maps).Update(&quot;active&quot;, 0)\n\t&#125;\n\treturn\n&#125;\nroutes/v1/actives.gopackage v1\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;strconv&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\n\t&quot;server&#x2F;models&quot;\n)\n\n&#x2F;&#x2F; 獲取已排除、未排除or全部的設備狀態\nfunc GetActives(c *gin.Context) &#123;\n\tactive :&#x3D; c.Param(&quot;active&quot;) &#x2F;&#x2F; 取得active值\n\n\treq :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 傳遞給GORM的參數\n\tres :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 準備回傳給前端的映射\n\n\tif active !&#x3D; &quot;&quot; &#123;\n\t\ti, err :&#x3D; strconv.Atoi(active) &#x2F;&#x2F; 字串轉數字\n\t\tif err !&#x3D; nil &#123;\n\t\t\tlog.Error().Err(err).Msg(&quot;字串轉數字錯誤&quot;)\n\t\t&#125;\n\t\treq[&quot;active&quot;] &#x3D; i\n\t&#125;\n\n\tres[&quot;data&quot;] &#x3D; models.GetActives(req)\n\tres[&quot;code&quot;] &#x3D; &quot;success&quot;\n\tc.JSON(http.StatusOK, res)\n&#125;\n\n&#x2F;&#x2F; 修改設備活躍狀態\nfunc EditActive(c *gin.Context) &#123;\n\tdeviceId :&#x3D; c.Param(&quot;device_id&quot;) &#x2F;&#x2F; 取得device_id值\n\n\treq :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 傳遞給GORM的參數\n\tres :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 準備回傳給前端的映射\n\n\tif deviceId !&#x3D; &quot;&quot; &#123;\n\t\treq[&quot;device_id&quot;] &#x3D; deviceId\n\t&#125;\n\n\tmodels.UpdateDeviceActives(req)                                      &#x2F;&#x2F; toogle所選擇設備\n\tres[&quot;data&quot;] &#x3D; models.GetActives(map[string]interface&#123;&#125;&#123;&quot;active&quot;: 1&#125;) &#x2F;&#x2F; 取得新的已排除設備列表\n\tres[&quot;code&quot;] &#x3D; &quot;success&quot;\n\tc.JSON(http.StatusOK, res)\n&#125;\n\n測試Postman PUThttp://localhost:10080/api/v1/actives/test001檢查是否回傳預想中的值\n獲取「異常但未被排除」設備狀態models/device_states.gopackage models\n\nimport &quot;time&quot;\n\ntype DeviceStates struct &#123;\n\tID         int       &#96;json:&quot;id&quot;&#96;\n\tDeviceId   string    &#96;json:&quot;device_id&quot;&#96;\n\tState      int       &#96;json:&quot;state&quot;&#96;\n\tUpdateTime time.Time &#96;json:&quot;update_time&quot;&#96;\n&#125;\n\ntype GetDeviceStatesResult struct &#123;\n\tActives\n\tState      int       &#96;json:&quot;state&quot;&#96;\n\tUpdateTime time.Time &#96;json:&quot;update_time&quot;&#96;\n&#125;\n\n&#x2F;&#x2F; 取得符合State條件的row，並JOIN device_info\nfunc GetDeviceStates(maps interface&#123;&#125;) (res []GetDeviceStatesResult) &#123;\n\ta, ok :&#x3D; maps.(map[string]interface&#123;&#125;) &#x2F;&#x2F; 型別斷言為map\n\tif ok &amp;&amp; a[&quot;state&quot;] &#x3D;&#x3D; 99 &#123;            &#x2F;&#x2F; 如果請求值為99，則為全選\n\t\tdb.\n\t\t\tModel(&amp;DeviceStates&#123;&#125;).\n\t\t\tSelect(&quot;*&quot;).\n\t\t\tJoins(&quot;left join actives on actives.device_id &#x3D; device_states.device_id&quot;).\n\t\t\tScan(&amp;res)\n\t&#125; else &#123;\n\t\tdb.\n\t\t\tModel(&amp;DeviceStates&#123;&#125;).\n\t\t\tSelect(&quot;*&quot;).\n\t\t\tJoins(&quot;left join actives on actives.device_id &#x3D; device_states.device_id&quot;).\n\t\t\tWhere(maps).\n\t\t\tScan(&amp;res)\n\t&#125;\n\treturn\n&#125;\nroutes/v1/states.gopackage v1\n\nimport (\n\t&quot;net&#x2F;http&quot;\n\t&quot;server&#x2F;models&quot;\n\t&quot;strconv&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n)\n\n&#x2F;&#x2F; 獲取「異常但未被排除」設備狀態\nfunc GetStates(c *gin.Context) &#123;\n\tstate :&#x3D; c.Param(&quot;state&quot;) &#x2F;&#x2F; 取得active值\n\n\treq :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 傳遞給GORM的參數\n\tres :&#x3D; make(map[string]interface&#123;&#125;) &#x2F;&#x2F; 準備回傳給前端的映射\n\n\tif state !&#x3D; &quot;&quot; &#123;\n\t\ti, err :&#x3D; strconv.Atoi(state) &#x2F;&#x2F; 字串轉數字\n\t\tif err !&#x3D; nil &#123;\n\t\t\tlog.Error().Err(err).Msg(&quot;字串轉數字錯誤&quot;)\n\t\t&#125;\n\t\treq[&quot;state&quot;] &#x3D; i\n\t&#125;\n\treq[&quot;active&quot;] &#x3D; 0\n\n\tres[&quot;data&quot;] &#x3D; models.GetDeviceStates(req)\n\tres[&quot;code&quot;] &#x3D; &quot;success&quot;\n\tc.JSON(http.StatusOK, res)\n&#125;\n\n測試Postman GEThttp://localhost:10080/api/v1/states/1檢查是否回傳預想中的值\n","slug":"Golang-Gin框架-GORM搭建APIServer-3","date":"2022-01-05T14:26:50.000Z","categories_index":"Golang","tags_index":"Gin,GORM,PostgreSQL","author_index":"猴子工程師"},{"id":"99518835ef4ff4e31bb03642fa3bcfe3","title":"Golang-Gin框架+GORM搭建APIServer(2)","content":"前言功能需求如下：\n\n取得所有的已被排除在外的設備與基本訊息\n根據device_id變換設備是否排除\n取得所有的「異常但未被排除」設備\n\n根據Restful的設計風格，我們應有以下三支API：\n\nGET(“/api/v1/actives/:active”) 獲取已排除、未排除or全部的設備狀態\nPUT(“/api/v1/actives/:device_id”) 將設備狀態變換\nGET(“/api/v1/states/:state”) 獲取「異常但未被排除」設備狀態\n\n整體流程：\n\n由配合device_actives表的API與device_states表的API開始\nrouter.go 將API Group，並將gin.Engine的建立移到此處\n改寫server.go\n\n本節目標\n建立API架構與路由註冊\n\n基本目錄結構server&#x2F;\n├── config &#x2F;&#x2F; 配置讀取yaml設定\n│   └── config.go &#x2F;&#x2F; 讀取yml設定\n├── middleware &#x2F;&#x2F; 中間件\n├── models &#x2F;&#x2F; 放置gorm的數據庫模型\n├── routers &#x2F;&#x2F; 路由邏輯\n│   ├── api\n│   │   └── v1\n│   │       ├── actives.go &#x2F;&#x2F; device_actives表的api\n│   │       └── states.go &#x2F;&#x2F; device_states表的api\n│   └── router.go &#x2F;&#x2F; 路由邏輯\n├── config.yml &#x2F;&#x2F; 設定檔\n└── server.go &#x2F;&#x2F; 入口\n\n編寫APIactives.gopackage v1\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n)\n\n&#x2F;&#x2F; 獲取已排除、未排除or全部的設備狀態\nfunc GetActives(c *gin.Context) &#123;\n\tlog.Log().Msg(&quot;GetActives&quot;)\n&#125;\n\n&#x2F;&#x2F; 修改設備活躍狀態\nfunc EditActive(c *gin.Context) &#123;\n\tlog.Log().Msg(&quot;EditActive&quot;)\n&#125;\n建立兩支針對device_actives表進行服務的API，我們下一節再進入GORM的編寫，因此先以log方式檢驗呼叫API是否符合預期\nstates.gopackage v1\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n)\n\n&#x2F;&#x2F; 獲取「異常但未被排除」設備狀態\nfunc GetStates(c *gin.Context) &#123;\n\tlog.Log().Msg(&quot;GetStates&quot;)\n&#125;\n\n路由註冊router.gopackage routers\n\nimport (\n\tv1 &quot;server&#x2F;routers&#x2F;v1&quot;\n\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc InitRouter() *gin.Engine &#123;\n\t&#x2F;&#x2F; 生成gin\n\tr :&#x3D; gin.Default()\n\n\tapi :&#x3D; r.Group(&quot;&#x2F;api&#x2F;v1&quot;)\n\t&#123;\n\t\t&#x2F;&#x2F; 獲取已排除、未排除or全部的設備狀態\n\t\tapi.GET(&quot;&#x2F;actives&#x2F;:active&quot;, v1.GetActives)\n\t\t&#x2F;&#x2F; 將設備狀態變換\n\t\tapi.PUT(&quot;&#x2F;actives&#x2F;:device_id&quot;, v1.EditActive)\n\t\t&#x2F;&#x2F; 獲取「異常但未被排除」設備狀態\n\t\tapi.GET(&quot;&#x2F;states&#x2F;:state&quot;, v1.GetStates)\n\t&#125;\n\n\treturn r\n&#125;\n\n改寫啟動文件server.gopackage main\n\nimport (\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\n\t&quot;server&#x2F;config&quot;\n\t&quot;server&#x2F;routers&quot;\n)\n\nfunc init() &#123;\n\t&#x2F;&#x2F; 調用zerolog結構化log輸出\n\tlog.Logger &#x3D; log.With().Caller().Logger()\n&#125;\n\nfunc main() &#123;\n\trouter :&#x3D; routers.InitRouter()\n\trouter.Run(&quot;:&quot; + config.Config.Server.Port)\n&#125;\n\n測試使用PostMan或其他API測試工具GET訪問：http://localhost:3601/api/v1/actives/1http://localhost:3601/api/v1/states/1PUT訪問：http://localhost:3601/api/v1/actives/1查看是否反饋正確的log\n","slug":"Golang-Gin框架-GORM搭建APIServer-2","date":"2021-10-21T04:27:30.000Z","categories_index":"Golang","tags_index":"Gin,GORM,PostgreSQL","author_index":"猴子工程師"},{"id":"bb9ea1063e87aa3740889487d9f40ff2","title":"Golang-Gin框架+GORM搭建APIServer(1)","content":"前言\n後端：Golang Gin框架\n資料庫：PostgreSQL\n\n這裡我們來做一個簡單的設備監控平台，初期階段有以下功能：\n\n儲存設備的基本資料(id, 類型, 地址)\n從資料庫中取得狀態異常的設備(id, 異常狀態代碼)\n讓使用者可以排除特定設備，因此需要一個設備活躍狀態的資料表(id, 活躍狀態代碼)\n\n以上需求構成了我們的三張資料表：\n\ndevice_info(device_id, type, address)&lt;靜態&gt;\ndevice_state(id, device_id, state, update_time)&lt;動態/未來會有其他功能進行寫入&gt;\ndevice_active(device_id, active)&lt;靜態&gt;\n\n本節目標\n建立基本目錄結構與資料庫\n讀取yml設定檔進行配置\n\n項目初始化基本目錄結構server&#x2F;\n├── config &#x2F;&#x2F; 配置讀取yaml設定\n├── middleware &#x2F;&#x2F; 中間件\n├── models &#x2F;&#x2F; 放置gorm的數據庫模型\n├── routers &#x2F;&#x2F; 路由邏輯\n├── config.yml &#x2F;&#x2F; 設定檔\n└── server.go &#x2F;&#x2F; 入口\n建立一個基本資料庫(不會用docker可跳過)建立data資料庫，建議使用docker-compose快速建立\ndocker-compose.yamlversion: &quot;3&quot;\nservices:\n  pgsql:\n    image: postgres\n    container_name: pgsql\n    volumes:\n      - .&#x2F;Postgresql:&#x2F;data&#x2F;postgres\n      # - .&#x2F;sqls:&#x2F;docker-entrypoint-initdb.d\n    environment:\n      POSTGRES_ROOT_PASSWORD: password\n      POSTGRES_DB: data\n      POSTGRES_USER: $&#123;POSTGRES_USER:-user&#125;\n      POSTGRES_PASSWORD: $&#123;POSTGRES_PASSWORD:-password&#125;\n    ports:\n      - &quot;5432:5432&quot;\n    restart: always\n\n1. 建立設備基本資料靜態表CREATE TABLE IF NOT EXISTS public.device_info\n(\n    device_id character varying(20) COLLATE pg_catalog.&quot;default&quot; NOT NULL,\n    type character varying(10) COLLATE pg_catalog.&quot;default&quot; NOT NULL,\n    address character varying(100) COLLATE pg_catalog.&quot;default&quot;,\n    CONSTRAINT device_info_pkey PRIMARY KEY (device_id)\n)\n\nTABLESPACE pg_default;\n\nALTER TABLE IF EXISTS public.device_info\n    OWNER to user;\n\nCOMMENT ON COLUMN public.device_info.device_id\n    IS &#39;設備id&#39;;\n\nCOMMENT ON COLUMN public.device_info.type\n    IS &#39;設備類型(&#39;&#39;CMS&#39;&#39;, &#39;&#39;TC&#39;&#39;, &#39;&#39;CCTV&#39;&#39;, &#39;&#39;eTag&#39;&#39;)&#39;;\n\nCOMMENT ON COLUMN public.device_info.address\n    IS &#39;設備中文地址&#39;;\n2. 建立設備活躍狀態靜態表-- Table: public.device_active\n\n-- DROP TABLE IF EXISTS public.device_active;\n\nCREATE TABLE IF NOT EXISTS public.device_active\n(\n    device_id character varying(20) COLLATE pg_catalog.&quot;default&quot; NOT NULL,\n    active integer DEFAULT 0,\n    CONSTRAINT device_active_pkey PRIMARY KEY (device_id)\n)\n\nTABLESPACE pg_default;\n\nALTER TABLE IF EXISTS public.device_active\n    OWNER to user;\n\nCOMMENT ON COLUMN public.device_active.device_id\n    IS &#39;設備id&#39;;\n\nCOMMENT ON COLUMN public.device_active.active\n    IS &#39;設備是否被排除(0: 否, 1:是)&#39;;\n3. 建立設備狀態表CREATE TABLE IF NOT EXISTS public.device_state\n(\n    id integer NOT NULL DEFAULT nextval(&#39;device_state_id_seq&#39;::regclass),\n    device_id character varying(20) COLLATE pg_catalog.&quot;default&quot; NOT NULL,\n    state integer DEFAULT 0,\n    update_time time with time zone,\n    CONSTRAINT device_state_pkey PRIMARY KEY (id)\n)\n\nTABLESPACE pg_default;\n\nALTER TABLE IF EXISTS public.device_state\n    OWNER to user;\n\nCOMMENT ON COLUMN public.device_state.id\n    IS &#39;流水號&#39;;\n\nCOMMENT ON COLUMN public.device_state.device_id\n    IS &#39;設備id&#39;;\n\nCOMMENT ON COLUMN public.device_state.state\n    IS &#39;設備狀態(0:正常, 1:自動通報異常, 2:人工通報異常)&#39;;\n\nCOMMENT ON COLUMN public.device_state.update_time\n    IS &#39;通報時間&#39;;\n編寫簡易的設定檔config.yml\nmode: &quot;debug&quot;\n\nserver:\n  port: &quot;3601&quot;\n\ndb:\n  type: &quot;postgresql&quot;\n  ip: &quot;localhost&quot;\n  port: &quot;5432&quot;\n  userID: &quot;thi&quot;\n  password: &quot;thi&quot;\n  database: &quot;device&quot;\n注意，yml的編寫縮排有強制規定\n編寫啟動入口文件server.gopackage main\n\nimport (\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\n\nfunc main() &#123;\n\tlog.Logger &#x3D; log.With().Caller().Logger()\n\tr :&#x3D; gin.Default()\n\tr.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n\t\tc.JSON(200, gin.H&#123;\n\t\t\t&quot;message&quot;: &quot;pong&quot;,\n\t\t&#125;)\n        log.Info().Msg(&quot;&#x2F;ping success&quot;)\n\t&#125;)\n\tr.Run(&quot;:3601&quot;)\n&#125;\n\n導入gin package，建立一個最基本的server\ngo mod init server\ngo mod tidy\ngo run server.go\n訪問 localhost:3601/ping，測試是否返回”pong”\n編寫讀取設定檔的方式server&#x2F;\n├── config &#x2F;&#x2F; 配置讀取yaml設定\n│   └── config.go &#x2F;&#x2F; 讀取yml設定\n├── middleware &#x2F;&#x2F; 中間件\n├── models &#x2F;&#x2F; 放置gorm的數據庫模型\n├── routers &#x2F;&#x2F; 路由邏輯\n├── config.yml &#x2F;&#x2F; 設定檔\n└── server.go &#x2F;&#x2F; 入口\nconfig.gopackage config\n\nimport (\n\t&quot;io&#x2F;ioutil&quot;\n\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\t&quot;gopkg.in&#x2F;yaml.v2&quot;\n)\n\nvar Config Configer &#x2F;&#x2F; 設定參數\n\n&#x2F;&#x2F; Config\ntype Configer struct &#123;\n\tMode string &#96;yaml:&quot;mode&quot;&#96;\n\tApi  struct &#123;\n\t\tUrl       string &#96;yaml:&quot;url&quot;&#96;\n\t\tFrequency int    &#96;yaml:&quot;frequency&quot;&#96;\n\t\tRefresh   int    &#96;yaml:&quot;refresh&quot;&#96;\n\t&#125; &#96;yaml:&quot;api&quot;&#96;\n\tServer struct &#123;\n\t\tPort string &#96;yaml:&quot;port&quot;&#96;\n\t&#125; &#96;yaml:&quot;server&quot;&#96;\n\tPgsql struct &#123;\n\t\tIP       string &#96;yaml:&quot;ip&quot;&#96;\n\t\tUserID   string &#96;yaml:&quot;userID&quot;&#96;\n\t\tPassword string &#96;yaml:&quot;password&quot;&#96;\n\t\tDatabase string &#96;yaml:&quot;database&quot;&#96;\n\t&#125; &#96;yaml:&quot;pgsql&quot;&#96;\n&#125;\n\nfunc init() &#123;\n\t&#x2F;&#x2F; 讀取yml文件\n\tyamlFile, err :&#x3D; ioutil.ReadFile(&quot;config.yml&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Error().Err(err).Msg(&quot;無法讀取yaml file&quot;)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F; 將yml檔解析成struct\n\terr &#x3D; yaml.Unmarshal(yamlFile, &amp;Config)\n\tif err !&#x3D; nil &#123;\n\t\tlog.Error().Err(err).Msg(&quot;yaml無法解析&quot;)\n\t\treturn\n\t&#125;\n\n\tif Config.Mode &#x3D;&#x3D; &quot;debug&quot; &#123;\n\t\tlog.Info().Msgf(&quot;yaml解析結果: %v&quot;, Config)\n\t&#125;\n&#125;\n\n將server.go 的port改成吃設定檔而非寫死，未來移植時不用從code一個一個找出來變更\nserver.gopackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;github.com&#x2F;rs&#x2F;zerolog&#x2F;log&quot;\n\n\t&quot;server&#x2F;config&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 調用zerolog結構化log輸出\n\tlog.Logger &#x3D; log.With().Caller().Logger()\n    \n\tr :&#x3D; gin.Default()\n\tr.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n\t\tc.JSON(200, gin.H&#123;\n\t\t\t&quot;message&quot;: &quot;pong&quot;,\n\t\t&#125;)\n        log.Info().Msg(&quot;&#x2F;ping success&quot;)\n\t&#125;)\n\tr.Run(&quot;:&quot; + config.Config.Server.Port)\n&#125;\n","slug":"Golang-Gin框架-GORM搭建APIServer-1","date":"2021-10-17T07:01:36.000Z","categories_index":"Golang","tags_index":"Gin,GORM,PostgreSQL","author_index":"猴子工程師"},{"id":"17e78b64810282ffd93c25608f3b11d9","title":"Golang-RCP協議","content":"RPC: 遠程行程(進程，單一程式)調用協議，使用TCP，屬於應用層協議，與http協議同層==可理解為調用內部函數一樣，調用網路中其他程式的函數==通過RPC協議，傳遞：函數名、參數，從原處調用另一處函數，返回結果到原處\n\n每個微服務彼此獨立\n程式與程式之間可使用不同程式語言\n\n前導知識 Go socketservernet.Listen() -- listener\nlistener.Accept() -- conn\nconn.read()\nconn.write()\ndefer conn.close()&#x2F;listener.Close()\n\nclientnet.Dial() -- conn\nconn.Write()\nconn.Read()\ndefer conn.Close()\n\nRPC使用步驟server\n註冊RPC服務對象，給對象綁定方法(1.定義類 2.綁定類方法)rpc.RegisterName(&lt;服務名&gt;, &lt;回調對象&gt;)\n創建監聽器listener, err :&#x3D; net.Listen()\n建立連結conn, err :&#x3D; listener.Accept()\n將連結綁定RPC服務rpc.ServeConn(conn)\n\nclient\n用RPC連結serverconn, err :&#x3D; rpc.Dial()\n調用遠程函數conn.Call(&lt;服務名.方法名&gt;, &lt;傳入參數&gt;, &lt;傳出參數&gt;)\n\nRPC相關函數\n==RegisterName()== 註冊服務\nfunc (server *Server) RegisterName(name&lt;服務名&gt; string, rcvr&lt;對應rpc對象&gt; interface&#123;&#125;) error\nrcvr必須滿足條件：(1) 必須導出：public, 首字母大寫(2) 方法必須有2個參數：public、內建類型(3) 第2個參數為指針(4) 方法只有一個error接口返回值\ntype Sample struct&#123;\n&#125;\n\nfunc (this *Sample) Test(name string, resp *string) error &#123;\n&#125;\n\nrpc.RegisterName(&quot;服務名&quot;, new(Test))\n==ServeConn()== 綁定rpc服務\nfunc (server *Server) ServeConn(conn io.ReadWriteCloser)\nconn: 建立連線的socket\n\n==Call()== 調用遠程函數\nfunc (client *Client) Go(serviceMethod string, args interface&#123;&#125;, reply interface&#123;&#125;, done chan *Call) *Call\nserviceMethod: 服務名.方法名args: 傳入參數(方法需要的參數)reply: 傳出參數(方法返回的結果)(建立變量，&amp;變量)\n\n\nDEMOserver端package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&quot;\n\t&quot;net&#x2F;rpc&quot;\n)\n\n&#x2F;&#x2F; 定義對象\ntype Sample struct &#123;\n&#125;\n\n&#x2F;&#x2F; 建立方法\nfunc (this *Sample) TestSample(name string, resp *string) error &#123;\n\t*resp &#x3D; name + &quot;返回&quot;\n\treturn nil\n&#125;\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 1. 註冊rpc，綁定對象方法\n\terr :&#x3D; rpc.RegisterName(&quot;service&quot;, new(Sample))\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;註冊rpc失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\n\t&#x2F;&#x2F; 2. 設置監聽\n\tlistener, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;設置監聽失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer listener.Close()\n\tfmt.Println(&quot;Start Listen...&quot;)\n\n\t&#x2F;&#x2F; 3. 建立連結\n\tconn, err :&#x3D; listener.Accept()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;建立連結失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer conn.Close()\n\tfmt.Println(&quot;Start Connect...&quot;)\n\n\t&#x2F;&#x2F; 4. 綁定服務\n\trpc.ServeConn(conn)\n&#125;\n\nclient端package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;net&#x2F;rpc&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 1. 用rpc連接server\n\tconn, err :&#x3D; rpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8800&quot;)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;rpc連接失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\tdefer conn.Close()\n\t&#x2F;&#x2F; 2. 調用遠程函數\n\tvar req string\n\terr &#x3D; conn.Call(&quot;service.TestSample&quot;, &quot;something&quot;, &amp;req)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Printf(&quot;調用遠程函數失敗，err &#x3D; %v&quot;, err)\n\t\treturn\n\t&#125;\n\n\tfmt.Println(req)\n&#125;\n\n\n序列化因為rpc使用go特有序列化gob，網路通訊中其他語言將會產生亂碼因此需使用通用序列化、反序列化方案：JSON、protobuf\n有內建package ==”net/rpc/jsonrpc”==\nserverjsonrpc.ServeConn(conn)\n\nclient端```conn, err := jsonrpc.Dial(“tcp”, “127.0.0.1:8800”)\n","slug":"Golang-RCP協議","date":"2021-09-09T13:26:59.000Z","categories_index":"Golang","tags_index":"RPC,網路架構","author_index":"猴子工程師"},{"id":"a47de5cab978593bde43925482e0346b","title":"Angular-色彩主題切換","content":"簡單介紹一下色彩切換功能\n建立2個獨立的主題$dark-primary: mat-palette($dark-primary, 900);\n$dark-accent:  mat-palette($mat-cyan);\n$dark-warn:    mat-palette($mat-red);\n\n$dark-theme: mat-dark-theme($dark-primary, $dark-accent, $dark-warn);\n&#x2F;&#x2F; class包裹其他樣式\n.dark-theme &#123;\n  @include angular-material-theme($dark-theme);\n&#125;\n\n$light-primary: mat-palette($mat-indigo);\n$light-accent:  mat-palette($mat-lime);\n$light-warn:    mat-palette($mat-pink);\n\n$light-theme: mat-light-theme($light-primary, $light-accent, $light-warn);\n&#x2F;&#x2F; class包裹其他樣式\n.light-theme &#123;\n  @include angular-material-theme($light-theme);\n&#125;\n\n在app.component建立切換功能material-UI中，menu、dialog等元件在OverlayContainer，與app.component平級，所以額外改變其樣式\nhtml&lt;div [class]&#x3D;&quot;theme&quot;&gt;\n  &lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;\n&lt;&#x2F;div&gt;\n\ntsimport &#123; Component, OnInit &#125; from &#39;@angular&#x2F;core&#39;;\n\nimport &#123; OverlayContainer &#125; from &#39;@angular&#x2F;cdk&#x2F;overlay&#39;;\n\n@Component(&#123;\n  selector: &#39;app-root&#39;,\n  templateUrl: &#39;.&#x2F;app.component.html&#39;,\n  styleUrls: [&#39;.&#x2F;app.component.scss&#39;]\n&#125;)\nexport class AppComponent implements OnInit &#123;\n\n  constructor(private overlayContainer: OverlayContainer) &#123;&#125;\n\n  ngOnInit() &#123;\n    this.overlayContainer.getContainerElement().classList.add(this.theme);\n    toggleTheme(&#39;light-theme&#39;) &#x2F;&#x2F; 看想要怎麼觸發\n  &#125;\n\n  theme &#x3D; &#39;dark-theme&#39;;\n\n  toggleTheme(newTheme) &#123;\n    this.overlayContainer.getContainerElement().classList.remove(this.theme);\n    this.overlayContainer.getContainerElement().classList.add(newTheme);\n    this.theme &#x3D; newTheme;\n  &#125;\n&#125;\n","slug":"Angular-色彩主題切換","date":"2021-08-30T12:40:22.000Z","categories_index":"Angular","tags_index":"Material-UI","author_index":"猴子工程師"},{"id":"957e53f31bd0fb9b5252ab0e19bc3aaa","title":"Docker-常用命令","content":"https://docs.docker.com/reference/\n幫助命令版本訊息\ndocker version\n系統訊息，包含鏡像與容器數量\ndocker info\n幫助命令\ndocker &lt;&gt; --help\n\n鏡像命令docker imagesdocker images\n\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\n鏡像倉庫源      標籤         id           創建時間        大小\n\n可選項\n\n-a, -all 所有鏡像\n-q, --quiet  只顯示id\n\ndocker searchdocker search &lt;名稱&gt;\n\n--filter&#x3D;STARS&#x3D;3000 搜索不小於3000\n\ndocker pulldocker pull &lt;名稱&gt;:&lt;版本 &gt;\n\ndocker rmidocker rmi -f &lt;名稱或id&gt;\n\n全刪\ndocker rmi -f $(docker images -aq)\n\n\n\n容器命令先有鏡像，才能創造容器\ndocker rundocker run &lt;參數&gt; &lt;image&gt;\n\n--name&#x3D;&quot;名字&quot; 容器名字\n-d 後臺運行\n-it 交互運行，可進入容器查看\n-p 指定port 主機:容器\n\ndocker run -it centos &#x2F;bin&#x2F;bash 啟動centos並進入\nexit 停止退出\nCtrl + p + q 不停止退出\n\ndocker psdocker ps 正在執行的\n-a  全部運行的\n-n&#x3D;1 最近1個\n-q 只顯示編號\n\ndocker rmdocker rm &lt;id&gt;\n\n全刪\ndocker rm -f $(docker ps -aq)\ndocker ps -a -q | xargs docker rm\n\ndocker start restart stop killdocker start &lt;id&gt;\ndocker restart &lt;id&gt;\ndocker stop &lt;id&gt;\ndocker kill &lt;id&gt;  強制停止\n\n後臺啟動docker run -d &lt;名字&gt; \ndocker ps  容器停止了\n常見錯誤： docker容器後台運行，需要前台進程，如果沒有就會自動停止\n\ndocker logsdocker logs -tf  &lt;id&gt;  全部\ndocker logs -tf --tail &lt;數量&gt; &lt;id&gt;  最近\n插播：如何在docker centos寫腳本\ndocker run -d centos &#x2F;bin&#x2F;sh -c &quot;while true;do echo SoGod; sleep 1;done&quot;\n\ndocker topdocker top &lt;id&gt;  查看進程訊息\n\ndocker inspectdocker inspect &lt;id&gt;  查看容器詳細訊息\n\ndocker execdocker exec -it &lt;id&gt; &#x2F;bin&#x2F;bash  進入正在運行的容器並開始新的終端\ndocker attach &lt;id&gt; 進入正在運行的容器，使用正在執行的終端\n\ndocker cpdocker cp &lt;id&gt;:&lt;容器路徑&gt; &lt;主機路徑&gt;  查看容器詳細訊息\n\n此處為手動。一般使用自動同步\n\ndocker commitdocker commit &lt;id&gt; &lt;目標鏡像名&gt;:&lt;tag&gt; 將容器提交為新的鏡像\n-m&#x3D;&quot;訊息&quot;\n-a&#x3D;&quot;作者&quot;\n","slug":"Docker-常用命令","date":"2021-08-22T07:33:44.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"猴子工程師"}]